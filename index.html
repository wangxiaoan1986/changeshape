<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Morphing</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: white;
            font-family: 'Inter', sans-serif;
        }
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }
        #ui-container {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background-color: rgba(20, 20, 30, 0.7);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        #change-shape-btn {
            background-color: #4a69bd;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        #change-shape-btn:hover {
            background-color: #5d81e2;
        }
        #color-palette {
            display: flex;
            gap: 10px;
        }
        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            transition: transform 0.2s;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        #info-text {
            position: fixed;
            top: 3%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <canvas id="webgl-canvas"></canvas>
    
    <div id="info-text"></div>

    <div id="ui-container">
        <button id="change-shape-btn">Change Shape</button>
        <div id="color-palette">
            <div class="color-swatch" title="Gold" style="background: linear-gradient(45deg, #ff8c00, #ffd700);" data-palette="gold"></div>
            <div class="color-swatch" title="Nebula" style="background: linear-gradient(45deg, #8a2be2, #00bfff);" data-palette="nebula"></div>
            <div class="color-swatch" title="Lime" style="background: linear-gradient(45deg, #32cd32, #adff2f);" data-palette="lime"></div>
            <div class="color-swatch" title="Sunset" style="background: linear-gradient(45deg, #ff4500, #ffff00);" data-palette="sunset"></div>
            <div class="color-swatch" title="Ocean" style="background: linear-gradient(45deg, #00008b, #00ced1);" data-palette="ocean"></div>
            <div class="color-swatch" title="Rainbow" style="background: linear-gradient(45deg, red, orange, yellow, green, blue, indigo, violet);" data-palette="rainbow"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
        // --- Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('webgl-canvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.position.z = 25;

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Makes the rotation smoother
        controls.dampingFactor = 0.05;
        controls.minDistance = 5;
        controls.maxDistance = 100;

        // --- UI Elements ---
        const changeShapeBtn = document.getElementById('change-shape-btn');
        const infoText = document.getElementById('info-text');
        const colorSwatches = document.querySelectorAll('.color-swatch');

        // --- Particle System ---
        const PARTICLE_COUNT = 20000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            depthWrite: false,
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- Shape & Color Data ---
        let currentShapeIndex = 0;
        const shapes = [];
        const shapeNames = ['Sphere', 'Cube', 'Torus', 'Galaxy', 'Wave'];

        const palettes = {
            gold: () => {
                const color = new THREE.Color();
                color.lerpColors(new THREE.Color('#ff8c00'), new THREE.Color('#ffd700'), Math.random());
                return color;
            },
            nebula: () => {
                const color = new THREE.Color();
                color.lerpColors(new THREE.Color('#8a2be2'), new THREE.Color('#00bfff'), Math.random());
                return color;
            },
            lime: () => {
                const color = new THREE.Color();
                color.lerpColors(new THREE.Color('#32cd32'), new THREE.Color('#adff2f'), Math.random());
                return color;
            },
            sunset: () => {
                const color = new THREE.Color();
                color.lerpColors(new THREE.Color('#ff4500'), new THREE.Color('#ffff00'), Math.random());
                return color;
            },
            ocean: () => {
                const color = new THREE.Color();
                color.lerpColors(new THREE.Color('#00008b'), new THREE.Color('#00ced1'), Math.random());
                return color;
            },
            // The rainbow palette calculates color based on particle index, not randomly
            rainbow: (i, total) => {
                const color = new THREE.Color();
                color.setHSL(i / total, 1.0, 0.5);
                return color;
            }
        };
        let currentColorFn = palettes.gold;

        // --- Shape Generation Functions (Unchanged) ---
        function createSphere() {
            const points = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                const radius = 10;
                points[i * 3] = radius * Math.cos(theta) * Math.sin(phi);
                points[i * 3 + 1] = radius * Math.sin(theta) * Math.sin(phi);
                points[i * 3 + 2] = radius * Math.cos(phi);
            }
            return points;
        }

        function createCube() {
            const points = new Float32Array(PARTICLE_COUNT * 3);
            const size = 18;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const side = Math.floor(Math.random() * 6);
                let x, y, z;
                if (side === 0) { x = size / 2; y = Math.random() * size - size / 2; z = Math.random() * size - size / 2; }
                else if (side === 1) { x = -size / 2; y = Math.random() * size - size / 2; z = Math.random() * size - size / 2; }
                else if (side === 2) { y = size / 2; x = Math.random() * size - size / 2; z = Math.random() * size - size / 2; }
                else if (side === 3) { y = -size / 2; x = Math.random() * size - size / 2; z = Math.random() * size - size / 2; }
                else if (side === 4) { z = size / 2; x = Math.random() * size - size / 2; y = Math.random() * size - size / 2; }
                else { z = -size / 2; x = Math.random() * size - size / 2; y = Math.random() * size - size / 2; }
                points[i * 3] = x;
                points[i * 3 + 1] = y;
                points[i * 3 + 2] = z;
            }
            return points;
        }

        function createTorus() {
            const points = new Float32Array(PARTICLE_COUNT * 3);
            const R = 8;
            const r = 3;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const u = Math.random() * 2 * Math.PI;
                const v = Math.random() * 2 * Math.PI;
                points[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                points[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                points[i * 3 + 2] = r * Math.sin(v);
            }
            return points;
        }
        
        function createGalaxy() {
            const points = new Float32Array(PARTICLE_COUNT * 3);
            const radius = 15;
            const arms = 3;
            const spread = 0.5;
            const armSeparation = 2 * Math.PI / arms;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r = Math.random() * radius;
                const armIndex = Math.floor(Math.random() * arms);
                const spinAngle = r * 0.3;
                const armAngle = armIndex * armSeparation;
                const angle = spinAngle + armAngle;

                const randomX = (Math.random() - 0.5) * spread * (radius - r) / radius;
                const randomY = (Math.random() - 0.5) * 0.2;
                const randomZ = (Math.random() - 0.5) * spread * (radius - r) / radius;

                points[i * 3] = Math.cos(angle) * r + randomX;
                points[i * 3 + 1] = randomY;
                points[i * 3 + 2] = Math.sin(angle) * r + randomZ;
            }
            return points;
        }

        function createWave() {
            const points = new Float32Array(PARTICLE_COUNT * 3);
            const size = 20;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const x = Math.random() * size - size / 2;
                const z = Math.random() * size - size / 2;
                const d = Math.sqrt(x * x + z * z);
                const y = Math.sin(d * 0.5) * 2.5;

                points[i * 3] = x;
                points[i * 3 + 1] = y;
                points[i * 3 + 2] = z;
            }
            return points;
        }

        // --- Morphing & Color Transition Logic ---
        
        function updateInfoText(text) {
             infoText.textContent = text;
             gsap.to(infoText, { opacity: 1, duration: 0.5 });
             setTimeout(() => {
                 if (infoText.textContent === text) {
                     gsap.to(infoText, { opacity: 0, duration: 0.5 });
                 }
             }, 2500);
        }

        function morphToShape(targetPositions) {
            updateInfoText('Morphing...');
            changeShapeBtn.disabled = true;
            const currentPositions = geometry.attributes.position.array;
            
            // Kill any ongoing animation on the positions
            gsap.killTweensOf(currentPositions);

            gsap.to(currentPositions, {
                duration: 3,
                ease: 'power3.inOut',
                onUpdate: function() {
                    const progress = this.progress();
                    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                        currentPositions[i] = this.vars.startPositions[i] + (targetPositions[i] - this.vars.startPositions[i]) * progress;
                    }
                    geometry.attributes.position.needsUpdate = true;
                },
                onComplete: () => {
                     updateInfoText(`Shape: ${shapeNames[currentShapeIndex]}`);
                     changeShapeBtn.disabled = false;
                },
                startPositions: [...currentPositions]
            });
        }
        
        function changeColors(paletteFn) {
            const currentColors = geometry.attributes.color.array;
            const targetColors = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i < PARTICLE_COUNT; i++) {
                const color = paletteFn(i, PARTICLE_COUNT);
                targetColors[i * 3] = color.r;
                targetColors[i * 3 + 1] = color.g;
                targetColors[i * 3 + 2] = color.b;
            }

            // Kill any ongoing animation on the colors
            gsap.killTweensOf(currentColors);

            gsap.to(currentColors, {
                duration: 2,
                ease: 'power2.inOut',
                onUpdate: function() {
                    const progress = this.progress();
                    for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                        currentColors[i] = this.vars.startColors[i] + (targetColors[i] - this.vars.startColors[i]) * progress;
                    }
                    geometry.attributes.color.needsUpdate = true;
                },
                startColors: [...currentColors]
            });
        }

        // --- Initialization and Event Listeners ---
        function init() {
            shapes.push(createSphere());
            shapes.push(createCube());
            shapes.push(createTorus());
            shapes.push(createGalaxy());
            shapes.push(createWave());

            const initialPositions = shapes[0];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const color = currentColorFn(i, PARTICLE_COUNT);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;

                positions[i * 3] = initialPositions[i * 3];
                positions[i * 3 + 1] = initialPositions[i * 3 + 1];
                positions[i * 3 + 2] = initialPositions[i * 3 + 2];
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            updateInfoText(`Shape: ${shapeNames[0]}`);
        }

        changeShapeBtn.addEventListener('click', () => {
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
            morphToShape(shapes[currentShapeIndex]);
        });

        colorSwatches.forEach(swatch => {
            swatch.addEventListener('click', () => {
                const paletteName = swatch.dataset.palette;
                currentColorFn = palettes[paletteName];
                changeColors(currentColorFn);
            });
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Update controls for damping effect
            controls.update();

            // The automatic rotation is now disabled to give user full control.
            // If you want it back, uncomment these lines:
            // if (!controls.enabled) {
            //    particles.rotation.y += 0.0005;
            //    particles.rotation.x += 0.0002;
            // }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>